[八股](/home/qxy/Desktop/Job/简历/baguNote.md)
[简历](/home/qxy/Desktop/Job/简历/note.md)

##### 0716
[cpp八股]，[杂八股]（17-21把cpp八股和mysql八股搞定）


【1】什么是左值和右值；   什么时候使用右值？什么是左值引用？
1.定义：左值：存放在内存，生命周期较长，可寻址；右值：内存或寄存器，生命周期短，一般一行就没了，不可寻址；
2.判断：可以用&符号取址的是左值，反之是右值；
【1.1】经典问题++x和x++返回的哪个是左值哪个是右值？
++x是左值，x++是右值；理由：++x是先x自增然后返回x，x可以取值因而是左值。x++返回的是当前x的值，然后再对x自增，‘当前x的值’不是x（很快被自增了），因而是右值。[注意]常量左值引用可以引用右值。
【1.2】什么是左值引用，什么是右值引用？
左值引用：对于左值的应用，就是日常使用的引用； 
右值引用：形式T&&a=1；赋予右值更长生命周期，避免类构造函数深拷贝的时间成本。
【1.3】移动语义：
std::move;将左值强转成右值，来支持右值引用，避免深拷贝的时间成本；
【1.4】完美转发：
情景：模板函数传进来的参数，右值参数会变成左值。
解决：forward<T>(val)保证参数保持左右值的特征。
```
[原始内容]左值和右值:
朴素理解:临时变量,很快创建很快被释放的值,常量值:右值; 被引用,指针记录的值,左值; x++,返回的是临时变量,左值.另一个[判断标准]:能取地址的值就是左值,不能取的是右值. ++x返回的是自身,右值.
左值引用:int i =0; int & j = i; j是左值引用. int && k = 11. k是右值引用. 
[右值引用的作用:]延长临时对象的生命周期,减少拷贝次数.
```

【2】智能指针是什么（是什么，为什么，怎么用），shared_ptr和unique_ptr的区别，以及性能对比。weak_ptr的作用是什么。
【2.1】内置引用计数，自动释放已分配的内存，解决内存泄漏问题。
【2.2】shared_ptr线程安全吗？
（线程安全定义）：不会出现野指针，意外析构等情况；
结论：同一个shared_ptr被多个线程读安全，被多个线程写不安全。
情景：线程A让1->2的时候线程B让2->3，由于引用计数修改和指针修改不是原子操作（先改指针指向再改引用计数），存在出现野指针的可能性
原因：引用计数和指针指向不是原子操作。
解决方式：上锁
【2.3】weak_ptr，目的解决循环引用的问题；
方法：weak_ptr指向的对象引用计数不改变；
【2.4】unique_ptr,拥有对象唯一所有权
两个unique_ptr不能同时指向一个对象。

【3】lambda表达式有哪些捕获类型

【4】多态以及实现机制

【5】虚基类是什么？多继承的时候，虚函数表指针怎么存储的

【6】using std::cin 和 在using namepace std后使用cin有什么区别

【7】死锁是什么，如何发现和避免死锁。

【8】内存泄漏如何调试

【9】core dump如何调试

【10】协程是什么，和线程比的优势是什么

【11】如何避免哈希冲突（对于unordered_map来说，其解决方式是什么）

【12】常用stl（会说vector，deque，unordered_map）

【13】unordered_map底层实现

【14】和unordered_map比，map除了查询复杂度高还有什么缺点

【15】vector，insert，emplace，pop，find的时间复杂度

【16.1】vector支持越界检查吗

【16.2】vector扩容机制

【16.3】emplace_back可以传对象吗

【17】构造函数，移动构造函数和拷贝构造函数的区别;深拷贝和浅拷贝的问题

【18】static使用场景和特点

【总结一下比较重要的点】
STL底层实现（特别是unorderedmap和vector）；
进程，线程协程概念和安全性（涉及操作系统的知识）；
static关键字；
智能指针；
虚函数；
拷贝构造；

-----------------------------------------------------
[mysql八股]
数据库索引，数据库引擎，数据库事务隔离性，数据库锁的粒度和mvcc

##### 0713
数据库DDL 数据定义语言; DML数据库操作语言;DQL数据库查询语言;
select * from user where name='li' group by gender having a='c' order by desc limit 10;

NoSQL: 非关系型数据库,其中比较典型的是redis非关系型数据库.

mysql执行SQL过程:sql语句输入mysql;1.连接器进行身份验证,2.分析器进行sql语法分析,3.优化器进行操作优化,4.执行器,和储存引擎交互,执行语句

InnoDB引擎;


##### 0703
目前还不是搞得很明白，但至少摸索出了一条通过git进行拉去和同步的方式。
首先git clone url，这个时候本地会出现一个master分支，以及好几个remotes/origin/xxx的远端分支
然后git checkout webserver，这个时候会查远端分支，如果有重名的，会在本地创建webserver分支并和远端关联上，
之后通过push和pull就可以在该文件夹下和远端同步信息了。

##### 0625
git进行版本控制
集中化的版本控制系统(Centralized Version Control Systems)CVCS; 分布式版本控制系统(Distributed Version Control System,DVCS);
git 三种状态:已提交(committed);已修改(modified);已暂存(staged);
git项目的三个工作区域: git仓库(.git directory), 工作目录(working directory), 暂存区域(staging area);
创建并切换到新的分支:
git checkout -b ...


##### 0602
sed -i 's#Welcome to nginx#QXY欢迎您#g' index.html
sed -i 's#<head>#<head><meta charset="utf-8">#g' index.html
docker stop mn : 暂停容器
docker start mn : 启动容器
docker ps -a:查看容器状态
docker rm mn : 删除容器

##### 0601
**docker run** 创建并运行一个容器 --name 容器名称; -p 端口映射 宿主机端口:容器端口; -d 后台运行; nginx 镜像名称;
唯一id；
5dec47c855603bed68b2646a653e37f3bc7c6b349807f5127d2b94f09443981c
查看容器运行日志:
**docker logs** mn
容器状态:
**docker ps**

进入nginx容器,修改html文件,添加标题

docker exec -it mn bash

docker exec:进入容器内部,执行一个命令
-it 给当前容器创建一个标准输入\输出中断,允许我们与容器交互
mn:要进入的容器名称
bash:进入容器后执行的命令,bash是一个linux终端交互命令	

##### 0531

周四,周五的计划:周四早上,晚上.主要是看视频学习.周五早上.看视频.周五晚上下班之后,开始仔细的制定十天的计划.还有就是算法题了从剑指offerI开始.

##### 0530

[Docker安装](https://blog.csdn.net/u012563853/article/details/125295985) 成功

[Docker配置镜像源.](https://blog.csdn.net/tiahaole/article/details/122679937) docker换源.

从docker hub中拉取nginx镜像. 常用操作:

**docker pull**: 从docker hub拉取镜像 
eg:docker pull Redis

**docker images**: 查看本地镜像库中的镜像
eg:docker save -o redis.tar redis:latest

利用**docker save**命令将nginx镜像加载到磁盘,再利用**docker load**命令加载回来.

删除镜像: **docker rmi**





##### 道听途说

一些听别人说的,看别人在群里写的,但我从来没遇到过的考点: 1.手写线程池.2.手写多线程?(都不知道啥意思) 3.手写跳表 4.手撕生产者消费者模式 用信号量和互斥锁写了一个 5.手撕STL中unordered_map的insert函数实现    void insert(int key,int value){}

本note主要记录每天做项目.八股的时候遇到的比较锁碎的没有整理的问题.note中并不是所有记录都有价值.主要当作字典来搜索.
每天晚上复习整理的内容有四大块:1.经典力扣题整理,这个是最重要也是最必要的. 2.项目八股的问题整理,就是这个文件中的记录,有价值的放进note里面. 3.sql整理.先在还没到背sql八股的时候,再看一遍数序语法. 4.科研记录整理.一天做了啥都不记得了.



##### 0425

HR面试问题准备:
[摘自阿里HR面面经](https://www.nowcoder.com/feed/main/detail/d50e9e0a3df4485e9502e341cc1b8368?sourceSSR=search)

项目:
[star]. **项目里面遇到的难点 怎么解决的 ？**
线程池的设计比较困难,因为线程池的内容是综合的,共享资源同步的问题,设计储存http连接的任务队列综合在一起.并且还和tcp连接epoll复用的部分有联系.

**如何解决的?**
首先,先分析逻辑,把它拆解成尽可能独立的部分.比如组件http队列的部分, 从共享资源取链对部分.每一部分逻辑比较简单.最后在规划如何把这些部分组合在一起.

比赛中遇到的困难,如何解决的.
就是第一天求解结果,不符合尝试. 沟通,交流.

个人:
**你研究生是做算法的,为什么要选择后端？**
1.我对比较抽象但逻辑确定的对事情比较感兴趣,我在研究生做的算法研究感觉更多是具象的,随机的. 2.算法找工作更难.

最有成就感的一些事？
瘦了40斤.
原生动力:我女朋友希望我瘦. 前期调研. 中间长时间持之以恒. 科学面对中间的挑战.

感觉到挫败感的事情？
科研

性格上的优点和缺点？
就用喜欢纠缠细节这个点.
67
有什么兴趣爱好？


**能不能接受11,11,6** 
1.研究生期间习惯这个状态 2.有健身习惯 3.对薪资的追求高于个人生活.



##### 0419

进程间通信

##### 0412

存储引擎和索引的对应关系:
ISAM


文件系统:
文件的构造,命名,存取,使用,保护,实现和管理方法,是操作系统关心的事情.操作系统处理文件的部分:文件系统.
文件系统的功能: 比较好记的:文件读,写,创建,压缩,加密,共享.. 比较陌生的:目录的管理, 文件的访问权限管理, 

页面置换算法:
最佳页面置换 OPT: 优先选择最长时间不会被使用的页面进行替换.(理论标准,没有算法可以做到)
先进先出置换 FIFO: 将最先被加入到内存中的页面进行替换. 不合理,因为被替换的页面可能就是被频繁使用的页面
最长时间未被访问置换 LRU
最少页面置换 LFU: 对一段时间内使用次数最少的页面进行置换.

##### 0411
面经:
性能测试的指标:
响应时间: 2-5-8秒原则
并发数:系统同时能处理请求的数目
QPS压力测试: QPS(query per second): 服务器每秒可以执行查询的次数 QPS = 并发数/平均响应时间
  QPS与哪些因素相关联,
  如何提高服务器的QPS

性能测试;负载测试;压力测试;稳定性测试


##### 0410
内存管理
内存管理主要做了什么:
[主要回答].内存的分配与回收:malloc,free; 逻辑地址到物理地址的转换; 内存扩充:内存空间扩充到磁盘空间; [次要回答].内存映射;内存优化;内存安全

内存碎片:
内部内存碎片(分配了进程,但是进程没有使用的碎片);外部内存碎片(两个内存分配之间,容不下新进程的碎片);(传统连续内存管理的弊病)

常见的内存管理方式:
连续内存管理(old school 淘汰不用):为一个进程分配连续的内存地址空间;

非连续内存管理: 段式管理:,页式管理,段页式管理,必须要配合虚拟内存技术使用.(这样在进程视角下,仍然可以通过连续的方式寻址内存(CPP指针))
页式管理:将内存分成一个个大小相等的页框中(通常很小4K).优点:减少内存碎片,提高利用率.缺点:不方便按照逻辑模块,实现信息共享和信息保护.
段式管理:将进程分成有逻辑信息的段的集合,为每一段分配连续的物理内存.(例如主程序段,子程序段,数据段,栈段)

段页式管理:先分段再分页;

虚拟内存:
独立.安全:隔离进程,每个进程认为自己独享内存,并且不可接触其他进程的物理内存.保证内存安全.
提升利用率:可以扩展到硬盘区域.
关键词:安全性,容量. 安全性:不同进程之间如果可以互相写,不安全. 容量,可以扩大接收大于实际物理内存的应用.

小关键词:
通过内存管理单元MMU(memory management unit)进行虚拟地址-物理地址的转换.

缺页中断:(和页缺失,页故障指的一件事情)虚拟页号找到对应的理页号不存在,出现页缺失,因为对应资源再磁盘空间还没有被加载到内存区域.

多级页表:<每个进程都要有自己的页表,因为虚拟地址到物理地址映射不唯一(每个进程都有一个0号地址)>.核心原因在与页表必须占用连续的存储空间,一级页表4MB不是关键,需要1K个连续页是问题的关键..B树/B+树.

TLB:Translation Lookasjde Buffer(快表), 页表的高速缓存,利用了局部性原理.

页面置换算法:OPT/FIFO/LFU/LRU


文件系统



*内存管理:0403*
内存管理的作用: 
1.内存的分配与回收 2.逻辑地址和物理地址的转换
内存管理方式: 1.连续分配管理方式:为用户进程分配的必须是一个连续的内存空间. 块式管理(古老); 缺点:产生碎片,内存利用率低.
2.非连续分配管理方式:允许为用户进程分类离散的内存空间. 页式管理,段式管理,段页式管理,
分页存储管理基本概念:将内存分成一个个大小相等的分区,(每个分区很小,4KB),每个分区称为:页框,页帧,物理块...
进程被分成一个个页面,储存到页框之中,地址不连续.页框通常比较小,保证了*内存的利用率*. 
存在问题:逻辑地址到物理地址的转换->引出虚拟内存. 页号,起始地址 ,偏移量
通过查询 页表 : 逻辑地址页号到物理地址的映射表. 页表项长度相同,页号隐含. 
块表: 页表的一个高速缓冲(cache),cpu寻址先查块表,查不到再查页表. 所利用原理:局部性原理
分页管理优缺点: 优点:空间利用率高; 缺点:不方便按照逻辑模块实现信息的共享和保护
分段: 按照程序自身逻辑划分地址空间. 段表: 逻辑段到实际内存中的位置. 优点:按照逻辑模块实现信息共享 缺点:段长过大分配空间不方便.会产生内存碎片.
端页式管理:先分段再分页; 地址查询的时候.先通过端表定位要查询的页表,再通过页表具体查询.

虚拟内存(虚拟存储技术): 概念明晰: 虚拟内存管理在上述 /连续的逻辑地址/ -> /不连续的物理地址/之外,还有一层向磁盘扩充内存的概念在里面.
传统分配方式缺点:一次性:1.作业一次全部装入内存后才能运行. 2.大量作业要求运行时,并发度下降; 驻留性:只需要访问作业一小部分就可以运行.


##### 0407
从输入URL到页面展示,所发生的过程:
客户端输入URL->通过DNS协议查到目标IP地址->IP路由->建立TCP连接->发送HTTP请求->处理请求并返回HTTP响应(HTML)->浏览器解析HTTP报文展示HTML;
就是HTTP之前先寻址,然后路由,然后TCP连接;

TCP可靠性保证:流量控制,超时重传,拥塞控制,校验和,ACK机制,即与连接

三次握手四次挥手

七层模型:
OSI七层模型,每一层作用:
物理层:     比特流的传输
数据链路层:  帧编码和误差纠正控制
网络层:     路由和寻址
传输层:     两台主机之间的通信
会话层:     程序之间的会话
表示层:     数据处理
应用层:     应用程序交互

TCP/IP四层模型:
网络接口:合并了OSI七层模型中的物理层和数据链路层; 

网络层:路由寻址;
协议:IP; ARP:由ip寻找mac地址; NAT:网络地址转换; 还有一些奇怪的协议,一般不熟悉的协议都优先思考一下是不是网络层的.RIP,OSPF,ICMP,BGP...

传输层:向两台终端设备进程之间的通信提供通用的数据传输服务.
协议:TCP/UDP

应用层:合并了OSI中的应用层,表示层和会话层; 应用程序之间的信息交换服务;定义了信息交换格式,消息交给下一层来传输.
协议:HTTP,超文本传输协议,web浏览器和web服务器之间的通信.
SMTP:邮件发送协议; POP3/IMAP邮件接受协议; FTP:文件传输协议; Telnet:远程登陆协议(明文); SSH:安全的网络传输协议(安全); DNS:通过域名查IP

TCP拥塞控制:
报文传输机制:cwnd未达到ssthrsh上限时,每次*2;
          当传输超时时,cwnd=1,ssthrsh/2;
慢开始:cwnd从1开始; 拥塞避免:cwnd达到ssthrsh上限时,每次自增1; 
快重传:3个ACK重传 快恢复:快重传cwnd=ssthrsh而不是归零.

##### 0406
上午:1.复习前一天的记录 2.以项目为基础展开复习.看服务器项目.从项目常问的一些问题开始入手准备 3.准备一个开场白,引入自己熟悉的领域<socket网络编程, TCP/IP协议, HTTP协议, 进程通信,同步,IO多路复用>这几个关键词.,
下午:面试. 面试完做科研; 晚上:写面经;算法题;


##### 0405
介绍一下非对称加密的方式
HTTPS中SSL中会产生几个随机数 3个.
3个.客户端->服务端 服务端->客户端 客户端公钥+加密->服务端 服务端私钥解秘
TCP和UDP的区别
指针和引用的区别:  1.本质常量指针 2.对取值等操作符进行了重载
多继承时的虚函数表是什么样的
C++的内存存储区
析构函数为什么要用虚函数

linux下如何创建子进程,进程创建的时候操作系统做了哪些事情?
fork(), 除了ppid和未决信号集.写时复制; 读时共享写时复制.

孤儿进程:子进程还在但父进程结束->托管给pid为1的进程.

僵尸进程:子进程结束但父进程没有通过 waitpid 回收资源. 导致子进程资源未能完全释放(task_struct结构和少量资源信息);解决方式:注册sigchild信号.

守护进程:后台运行,独立于控制终端.
创建方式:父进程fork,退出,setsid创建新会话

大端: 0x11223344-> 11 22 33 44; 小端:0x11223344-> 44 33 22 11;



##### 0404

冒泡排序 稳定 n2
选择排序 不稳定 n2
插入排序 稳定 n2
希尔排序 不稳定
推排序 不稳定; 快速排序 不稳定; 归并排序 稳定
桶排序 稳定; 计数排序 稳定; 基数排序 稳定 

哈希表:

###### **哈希表:**

哈希表:根据键而直接访问内存存储位置的数据结构.(散列表,hash table). 底层使用数组实现(但我觉得起始更像数组+链表,因为数组对应下标存储的不是数,而是键值对).
储存数据:通过键经过哈希映射到hashmap中的位置
哈希函数:快速将一个数值转换成哈希值(整数).所以哈希表必须保持哈希值的计算一致.
**哈希冲突:**如果两个不同的输入通过哈希函数得到了相同的哈希值=>哈希冲突
哈希冲突处理方式:*(1)拉链法*.数组指向不是具体的值,而是一个链表,指向同一个哈希值则在后端插入(key-value pair)如果长度超过8转换成树结构,小于6回到链表. (2)*开放寻址法*:实现当前位置若被占用了,则后移动一位.(3)*公共溢出区(不太重要)*
**哈希扩容:**当哈希表被占用的位置比较多的时候,出现哈希冲突概率变高,则需要进行哈希扩容.负载因子(hash_map为0.75).注意扩容之后要重新哈希.如果一次性搬运会花费大量时间.redis的策略是每次插入的时候搬运一个非空元素直到搬完.
哈希函数设计:挺多的.就记住三个就行了.平方取中,除留余数,随机数法.

哈希函数的应用题:大数找topk
**如何从大量的 URL 中找出相同的 URL？**
题目描述 给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。
**MA:** 1.先把a用哈希函数分到M个小文件中,每个文件可以单独放进内存.2.再把b用哈希函数同理(键位url,值为ct次数). 遇到重复的直接保存在一个单独的文件中.
**A:** 首先计算空间啊:url共250GB+,内存4GB,因此放进70个小文件中即可. 具体把一个url放进一个小文件并哈希的方法,首先得到哈希值hash(url),这个哈希值用来唯一寻值一个url.然后比如对hash%70,余数代表与值对应的小文件. 对于挑文件的过程,遇到重复的直接输出


各种树的概念梳理:
树:n个点,n-1个边,连通
二叉树:每个节点都有左子树和右子树(可以为空). 
满二叉树:除最后一层没有节点外,其余层的节点都有两个子结点.
完全二叉树:出了最后一层以外是满二叉树,最后一层从左向右排
平衡二叉树: 一颗二叉树且具有如下性质:1.可以是空树 2.如果非空,左右子树的高度差的绝对值不超过1,且左右子树均为平衡二叉树.
常见的平衡二叉树: 红黑树,AVL树,
**逻辑**:
首先,为了高效查找.定义了
**二叉排序树**:(二叉搜索树,二叉查找树,一个意思).该树满足1.左子树的值均小于根,根小于所有右子树的值 2.左子树,右子树均为二叉排序树. 这样可以通过路径搜索的方式查找需要的节点. 但二叉排序树可能退化成线性的.因此需要加入
**平衡二叉树的概念**:一颗平衡二叉树且具有如下性质:1.可以是空树 2.如果非空,左右子树的高度差的绝对值不超过1,且左右子树均为平衡二叉树.一个平衡的二叉排序树可以保证logN的查找效率. 平衡的二叉排序树 就是
**AVL树:**:平衡的二叉排序树.但对于频繁插入删除的场景,AVL树旋转很麻烦.因此提出
**红黑树:**.红黑树调整树结构频率低,查找效率略慢于AVL但也是logN级别的.
红黑树优势:可以实现logN级别的查找效率并且调整(插入删除)并不频繁.
应用:1.哈希表解决哈希冲突可能会用到红黑树 2.epoll在内核注册的内核事件表,用到了红黑树. 3.C++中有序map,set容器.

B树,B+树:
磁盘存储文件:(轨区,扇区),偏移量
m叉树: 是一个多级索引的实现, { (m-1)个键, m个下级索引, (m-1)个直接索引, 交叉排列, }
缺点:m叉树的构建没有规则约束,可能退化成一个链表

B树: 有规则的构建m叉树,保证树比较'满'.不会退化成链表
规则:1.非叶子节点的根节点:至少有两个子结点 2.非叶子非根节点:至少有ceil(m/2)个子节点.(当前点满了才分裂的保证) 3.所有叶子节点在同一层
B+树:所有的索引都在叶子节点,非叶节点没有记录的指针.(也就是说非叶节点只有判断作用没有访问作用.).实现了一个多级索引.
优势:B+树的m叉的m可以更大,因为其非叶节点不带有索引,可以承载更多维度.对同样的内存空间,B+树更加矮胖; 数据更紧密(缓存命中率更高); 全节点遍历更快(只需要遍历最后一层链表.)
应用:数据库.

哈夫曼树:对带权的点集建立一颗二叉树,使sigma(路径长*点权值)最小. 构建方法:每次都找最小的两个元素合并连接,新元素再放进列表里,直到列表里只有唯一的元素.

拓扑排序:对有向无环图的节点排序,保证排序后节点顺序不违反边顺序. 排序方法:对入度为0的点入栈,擦除该点的边,再找入度为0的点,依次dfs.直到所有点都被遍历.

##### 0403

**操作系统:**
什么是操作系统: 程序; 应用程序和硬件之间的桥梁; 帮助进程获取计算机上的软硬件资源,而不用将敏感资源暴露出来.
具体是如何帮助进程获取进程资源的呢,通过系统调用的方式.
系统调用: 通过执行系统调用,从用户态切换到内核态,获取系统资源完成相关操作
例如:文件管理(读写),内存管理,进程管理

进程和线程的联系和区别;进程的三种状态

进程的调度算法:先来先服务, 短作业优先, (important)时间片轮转, 多级反馈队列(综合考量)



**10种经典排序算法及其稳定性**:
冒泡排序: 稳定
选择排序: 不稳定
插入排序: 稳定
希尔排序: 不稳定

归并排序: 稳定
快速排序: 不稳定
堆排序:   不稳定

计数排序: 稳定
桶排序:   稳定
基数排序:  稳定

**进程和线程和协程的区别:**
先阐述进程和线程的相同点:
线程和进程在linux下的联系:在内核中都通过task_struct进行表示.cpu调度执行是一样的. 

进程和线程的区别:线程可以更方便的通信(通过共享的全局内存区)<项目中所有子线程都可以访问主线程锁创建的 任务队列 和 数据库连接池>; 线程创建更快,共享虚拟地址空间;
linux下取分进程或线程,要看其是否有独立的地址空间.

协程:
场景: 任务非常小,线程之间要频繁切换.协程和任务(task)之间一一对应,大量协程分享少量的线程.协程切换时程序行为(run time)而不是系统行为

总结:进程(process),线程(thread),协程(routine); 进程是CPU分配资源的最小单位, 线程时系统调度的最小单位; 线程共享一份全局内存区,包括堆空间; 协程:任务切换在run time中实现.不需要系统中断,

##### 0331
大端/小端字节序
close和shutdown的区别

##### 0330

**[复习]**
先,重走一遍webserver
计算机网络,操作系统老知识
关于epoll/select的不同


##### 0329
CPP11新特性:

1.空指针 nullptr

2. lambda表达式
```cpp
auto basiclambda = [] {cout<<"hello,world!"<<endl;};
basiclambda();
auto add = [] (int a,int b)->int {return a+b;};
auto add5 = [](int x){return x+5;};
```
本质:重载了operator()的类,即一个匿名仿函数.lambda表达式只有在被调用的时候,类才会实例化.  '[]'可以以值或者引用的方式捕获外部变量并在内部进行操作.
[注意:]捕获的应用场景.对于回调函数,调用函数会规定回调函数的传入参数和返回值.而此时回调函数需要额外的局部变量才能完成函数功能,此时就不能显示的在参数传递的部分传参了,而需要使用闭包.
```cpp
#include <algorithm> 
 void scan( int* a, int length, std::function<void(int)> process) 
 {  
 for(int i=0; i<length; i++) {   
 process(a[i]); 
 } 
 } 
 int main()  
 {   
 int a[10] = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };   
 int threshold = 5;   
scan(a, 10,
     [threshold](int v)
  { if (v>threshold) { printf("%i ", v); } }
  );  
  printf("\n");   
  return 0;  }
```
lambda表达式不允许重载,不允许引入模板类.

使用auto和detype进行静态类型推导.

基于范围的for循环 (越来越像python了.)


**[CPP视频]** 185/121

**STL诞生**
STL: 标准化的 *数据结构和算法库*

STL: standard template library 标准化模板库
容器,算法,迭代器
STL几乎所有代码都采用了模板类或者模板函数
STL 六大组件:
*容器,算法,迭代器,仿函数,适配器,空间配置器*
迭代器:容器和算法之间的交合剂
容器:存放数据的数据结构. 数组,链表,栈,队列,集合,映射表. 序列式容器:值的排序,容器中每个元素都有固定的位置.关联式容器,元素之间没有顺序关系.
迭代器:提供一种方法,使之能够依照顺序访问某个容器所含的各个元素,而又无需暴露该容器内部的表达方式.

**vector存放内置数据类型**
容器: `vector`
算法: for_each
迭代器: vector<int>::iterator

**运算符重载**
+-*/;
operator+: 通过成员函数重载+号
通过全局函数重载+
Person operator+ (Person &p1, Person &p2)

[补充:]浅拷贝:编译器提供的拷贝赋值操作;无参构造,有参构造,拷贝构造-[构造函数的参数就是原类型]; 编译器提供的拷贝构造函数只进行拷贝赋值.对于指针变量就会存在两个实例化类指向同一个内存地址的情况.析构就会出问题.
**拷贝构造函数调用时机**:1.类赋值 2.值为参数传递 3.以值的方式返回局部对象 注意:不是只有赋值的时候会调用拷贝构造,类对象作为值传递和返回给函数的时候也会调用拷贝构造. 




##### 0322
**复习:**
1.0->1.1: 错误代码更多了,默认长连接,支持虚拟主机, **缓存处理:控制策略更多;带宽优化,支持一部分资源**
1.1-2.0: 网络复用,**二进制分帧; 头压缩**
2.0->3.0: QUICK UDP, 线头阻塞, 识别ack, **流量控制,连接迁移**


##### 0321
早上:整理0320笔试题的遗漏知识点, 腾讯综测, 看cpp视频(继承看了,模板能看到哪算哪,早上看完后面就开始准备数据结构相关的东西了)
p127-131
**cpp视频**
**继承**
好处:减少重复代码
语法:class 子类: 继承方式(public...) 父类{ ... }
术语:子类--派生类  父类---基类

**继承方式**
继承方式: 1.公共继承 2.保护继承 3.私有继承
3种继承方式均不能访问父类中的私有内容. 公共继承:父:公共->子:公共. 保护: 父:公共->子:保护 私有:父:公共,保护->子:私有
*注意:* 类中的公共的成员方法可以访问私有成员变量. 是类中的静态函数只能访问静态成员变量.

**继承中的对象模型**
父类中,所有非静态成员属性都会被子类继承下去
私有成员属性时被编译器给隐藏了,因此访问不到,但确实继承下去了.

**继承中构造和析构顺序**
父类构造->子类构造->子类析构->父类析构

**继承同名成员处理方式**
通过子类对象访问父类同名成员,需要加作用域 s1.Base::m_A
如果子类和父类成员函数同名,子类会隐藏调所有的父类同名成员函数(包括重载的函数)
*注意:* 多态和继承是不同的,多态是父类声明子类对象,想要灵活调用子类函数,需要在父类中先写一个虚函数.继承的话是子类声明子类对象.使用作用域是调用父类的函数.

--------------


**事物的四个特性:**
原子性,隔离性,持久性, 一致性
事物是逻辑上的一组操作,要么都执行,要么都不执行.

**ps**:liunx系统中查看进程命令, ps process status 参数: 
-a: 显示终端上的所有进程，包括其他用户的进程
-A: 显示所有进程
-aux: 显示所有包含其他使用者的进程
-ef: e和A一样,显示所有进程,f是表示形式的命令. 目前资料没有说明aux和ef有特别大区别.都是显示所有进程.
ps:进程快照.不能动态显示进程信息.
"pstree -p 进程ID"可查看主线程和子线程之间的关系
pstree 命令会将所有进程以树状图形式显示，方便查看进程之间的父子关系.pstree就是用来显示进程父子关系用的.
"ps -aL | grep 进程名"不能查看*主线程有哪些子线程*: | grep是一个常见的筛选命令,将ps -aL输出中含有进程名关键字的行保留下来输出.由于-aL命令会显示子线程信息,所以可以查看子线程
总结:ps确实不了解.考的时候就只能蒙了这样子.

**netstat**:
netstate 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。 

**排序算法机理:**
掌握了:
归并排序,快速排序,推排序

需要了解 插入和希尔排序中,每一次遍历之后均不能唯一确定元素位置(因为后面的还可能插进去)
**冒泡排序**: 比较,交换,遍历. 不停的遍历相邻元素,如果前一元素比后一元素大,则交换.规模一点点减少(N-1).最坏时间复杂度ON2(反序排列,每次遍历只是把最大的放到最后面,要遍历n次).平均ON2

**选择排序**:最原始的排序方式. 遍历所有未排序元素,把最小的放到最前面,每次必然是ON2的复杂度.(比冒泡还low,冒泡起码运气好还是有ON的可能)

**插入排序**: 选择排序是一点点减少遍历的规模(N-1),插入排序是一点点增加遍历的规模(1-N). 扑克牌排序算法,也是平均ON2

**希尔排序**: 有二分思想的插入排序,平均OlogN,最差ON2
----上面是比较排序,下面是非比较排序(需要额外空间)
**计数排序**: 对min-max之间元素做哈希. 额外申请个数组,利用哈希思想对数组元素对号入座,然后遍历哈希数组自然就是排好了序的.但当待排序数组很稀疏的话,计数排序可能会复杂度远高于ON2.

**桶排序**:先把数据尽可能平均分到K个桶里,桶和桶之间存在严格序关系,对桶内元素进行排序.

**基数排序**: 先对每个数字的个位排序,然后十位,...一直到最高位.相当于要遍历数位*N次,对于稀疏数组或者最大位很高的数组不友好.

##### 0320
**中兴笔试题A(35'):**
1.下列Python代码：
import numpy as np
print np.sqrt(6*np.sum(1/np.arange(1,1000000, dtype=np.float)**2))
将近似输出什么？_______
A圆周率π
B自然底数e
C2的算术平方根√2
D黄金分割比φ
**分析:**原答案至少>sqrt(9),这样的话只有A有可能满足

2.计算机网络中，子网划分是通过借用IP地址的若干位主机位来充当子网地址从而将原网络划分为若干子网而实现的，现假设北京市某单位分配到一个B类IP地址，其网络地址为129.250.0.0，该单位有4000台机器，平均分布在16个不同的地点，试给每一地点分配一个子网号码，要求能分配的子网数最多的情况下，每个子网里面的主机数也能容纳一个地点的所有主机，则子网掩码选择为多少，这种情况下最多可以划分多少个子网？（  ） 
**分析:**4000/16=250, 需要8位来作为主机地址. 所以子网掩码是255.255.255.0; 划分子网这里只能看选项了,目前主流选项都还是算得是有效子网(也就是不算全0,全1的),所以是254.

3.对于下列关键字序列，不可能构成某二叉排序树中一条查找路径的序列是？
A.  90，17，83，24，85，71
B.  90，18，89，32，86，33
C.  19，87，75，27，34，36
D.  10，23，69，66，31，32
**分析:**二叉排序树:所左子树所有点小于根,右子树所有点大于根.A中85再83的左子树中,又大于83,矛盾.这个题不知道二叉排序啥意思,所以是蒙的.
- [ ] **准备:**数据结构各种树的定义层次的梳理

4.
```cpp
public class Test1 {
  public static void main(String args[]) {
    int m;
    //这里设置m的值
    switch (m) {
      case 0: System.out.println("case 0");
      case 1: System.out.println("case 1"); break;
      case 2:
      default: System.out.println("default");
    }
  }
}
```
请问m为什么值时能使程序输出default？
A.0  B.1  C.2  D.都不对

**分析:**switch中进入点如果不写break的话,会继续往下顺序执行.所以case 2的时候会输出default.就是不知道这个知识.知道了就不会错了.

**准备:**事物的四个特性还要再看看.
**准备:**linux常见的进程/网络操作命令 ps/netstate


20.在排序中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。下列排序方法中，哪个排序算法不能在每一趟排序结束能够确定一个元素最终位置？
A简单选择排序  B冒泡排序  C希尔排序  D快速排序  E堆排序

**准备:**了解这些常见排序方式的算法机理(数据结构)





##### 0318
**new delete malloc free的关系和区别**
联系:都用来在堆区申请和释放内存
区别:1.new/delete是c++关键字而malloc/free是函数. 2.使用上,new不用指定数据类型,不用声明内存大小 3.对于类对象,delete会调用析构函数 而free不会.

**delete与 delete []区别**
delete[] 对数组中每一个元素调用析构函数


##### 0317
看多态部分.(虚函数)
135-140;

**cpp视频:**
118友元-全局函数做友元.
在类内friend声明全局函数,可以在外面定义友元全局函数.
friend void goodGay(Building *building);
友元定义在哪里都可以,只要在类内就行.

友元类:
friend class GoodGay;
和友元函数定义一样,在类中以friend关键字声明,就可以访问私有权限.

成员函数做友元
friend void GoodGay::visit();
总结,在类内可以使用frend关键字声明友元全局函数,友元类和友元成员函数

---
**多态**: *静态多态*:函数重载,运算符重载; *动态多态*(一般所指的多态):派生类和虚函数实现运行时多态
静态多态:编译时确定函数地址, 动态多态:运行时确定函数地址
虚函数 virtual:实现动态多态-地址晚绑定
动态多态满足条件:
1.有继承关系; 2.子类*重写*父类的虚函数(重写!=重载,重写函数和原函数(返回值,名称,参数列表)要完全相同);
动态多态的使用:
1.**父类的指针或者引用**指向子类的对象

多态底层原理:
当子类重写父类虚函数
子类中的虚函数表内部会替换成子类的虚函数地址
&Animal::speak => &Cat::speak
当父类的指针或者引用指向子类的对象的时候,就发生了多态

对于多态的个人理解:
1.父类引用向子类对象:
  一个更广泛的说法是:基础类的指针指向一个派生类的对象:
    语法逻辑便是:忽略所有派生类中的类型定义/重写,只能访问基础类定义的成员函数和变量
所以虚函数的出现巧妙绕过了这一点.虚函数的地址通过虚函数指针指向虚函数表访问,而子类和父类的虚函数指针名一样,指向的虚函数表可以不一样.所以表面上使用的是父类的指针,但实际上指向了子类的虚函数表. (但正常指针又不会有这种效果,因为指针类变量仍然存在栈空间之中)

---
纯虚函数和抽象类:
纯虚函数: virtual 返回值类型 函数名 (参数列表) = 0;
virtual void func() = 0;//纯虚函数 单纯为了占个名,扩展
抽象类:拥有纯虚函数的类称为抽象类;

抽象类无法实例化; 子类必须重写纯虚函数,否则无法实例化;

---
**虚析构与纯虚析构**
父类析构函数无法delete在子类中new出来的变量.
纯虚析构:变成抽象类
虚析构:对父类(基类)中析构函数加virtual,析构函数会走子类
纯虚析构:纯虚析构必须有具体实现(函数外)
note:只有要解决多态时子类析构代码调不到的问题才会使用到虚析构.
**复习:**
this指针指向调用该非静态成员函数的对象.

int * const a;
HTTPS中加密原理.
TSL加密原理:
1.服务端申请ssl证书
2.用户和服务器通过tls通信
  2.1客户端发送支持的TLS版本,加密套件,第一个随机数(客->服)
  2.2服务端确认TLS版本,加密套件,第二个随机数(服->客)
  2.3服务端发送证书,公钥 (服->客)
  2.4.1客户端生成预主密钥(第三个随机数),通过公钥加密后发送 (客->服)
  2.4.2服务端得到加密后的信息后,通过自己的私钥进行解秘,得到预主密钥.
  2.5(1,2随机数+预主密钥)=会话密钥
总结:得到会话密钥的过程是非对称加密,核心在于服务端有一个公钥加密-私钥解秘的过程,保证客户端和服务端的预主密钥不会被第三方直到.(但加密过程使用了三个随机数.)

**哈夫曼树**
**哈夫曼树原理,哈夫曼编码应用**
具有最小带权路径长度的树.
贪心+归并

OSI 7层网络模型: 物理,数据链路,网络,传输,会话,表示,应用
SSL,TLS是会话层协议(震惊); 

TCP/IP协议四层模型: 网络接口层,网络层,传输层,应用层. (就是保留网络和传输,网络以下合并成一层,传输以上合并成一层.)
应用层协议:比较熟悉的HTTP,DNS; 一般熟悉的:FTP(传文件),SSH,SMTP(电子邮件),telnet; 有点陌生的:DHCP,IMAP
传输层:TCP.UDP
网络层:比较熟悉:IP,ARP(ip反解mac),ICMP(错误报告), 陌生的:RIP,OSPF(路由选择协议),BGP,NAT
网络接口层:MAC

##### 0316
118-119
**tcpip**
对有效子网的思考:如果是为了避免混淆,例如
126.191.0.0/24 和126.191.0.0/16之间的混淆,这是不成立的,因为这两个你只能用一个.如果你用了16,那么/24中很多网段会被当做主机地址分出去.总之不可能在两个划分之间存在冲突.只可能是解析的冲突(路由器不识别等等).但后来有种说法是先在这个冲突已经被解决了.所以只要记住有效子网是子网-2就行了,没有实际应用意义.


**cpp八股:**
对try03的一些语句的解释.返回*this是返回this指针所指向的值,就是当前结构体.但是.以值传递的时候会调用拷贝构造函数,拷贝出另外一个类进行返回.如果想返回当前类,必须指定返回的是函类的别名.(本质上是一个const指针),这样才能保证返回的值可原来的class是同一个.再函数外接收的时候,也要指定别名接收.(指定是const指针所封装的别名这样).

this在成员函数的开始执行前构造，在成员的执行结束后清除。

delete this 会发生什么? 在linux系统上测试会造成内存溢出

**内联函数:**
调用简单函数的时候提高运行效率(看起来像函数,但实际执行不通过转子函数返回的过程)
要求:不能有循环和switch; 定义在调用之前出现; 不能进行异常接口声明

118友元-全局函数做友元.
在类内friend声明全局函数,可以在外面定义友元全局函数.
friend void goodGay(Building *building);
友元定义在哪里都可以,只要在类内就行.

友元类:
friend class GoodGay;
和友元函数定义一样,在类中以friend关键字声明,就可以访问私有权限.


##### 0315
84-85, 94-98, p109-117
**复习**
IP地址的规则:
广播地址和主机地址:
每一个子网都会有一个广播地址和网络本身地址.例如C类192.168.0.0/25 则最后7位地址分配本地主机,但是全0和全1要保留下来,因此只有128-2台主机可以被分配(192.168.0.0 000 0001-192.168.0.0 111 1110)

有效子网:
172.16.0.0/27 : 子网数2^11, 主机数:2^7, 
子网数:2^m-2 (m=子网掩码位数-主机类型位数) (这里的2是为了更大网络的广播和单播)
主机数:2^n-2 (n=32-子网掩码数) (这里的2是为了广播和单播)

**cpp视频**
函数的默认参数;函数的占位参数:
函数重载:
参数类型不同,个数不同,顺序不同.可以定义两个函数.编译器通过输入参数判断使用的是哪个函数.

成员函数分类:
无参构造,有参构造; 普通构造函数,拷贝构造函数;

调用,括号法,显示法,隐式法
**拷贝构造函数调用时机**:1.类赋值 2.值为参数传递 3.以值的方式返回局部对象
如果函数传参的时候,类没有定义拷贝构造函数,程序会使用默认的拷贝构造函数.
如果定义了有参构造,编译器就不再提供默认构造; 如果定义了拷贝构造,则编译器不再提供任何构造函数.

深拷贝,浅拷贝
浅拷贝:(a=b这种)等号赋值操作
深拷贝:堆区重新申请空间,进行拷贝赋值

new/malloc 都是在堆区申请一块内存,返回的是指向这块内存的首地址(指针);**堆区数据由程序员手动开辟也需要由程序员手动释放.(通常在析构函数中释放)**
浅拷贝:堆区内存重复释放;本质是指针浅拷贝只复制原指针指向的地址.这样两个指针指向同一块地址.
深拷贝:对于指针的深拷贝.复制原指针所指向的内容到一块新内存,新指针指向该新内存,这样两个指针就不是指向一块内存了.

Q?这里为什么说对于堆区的内存要小心,不应该是对于指针变量指向的内存要小心吗?
A因为对于栈区的内容,系统会自己释放,不用你操心,就算多个指针指向了一个栈内存地址,系统释放也不会bug.只有堆内存需要自己释放.只从内存管理的角度来讲,只有堆内存的东西会出现重复释放的错误.但是从数据安全的角度来讲.两个指向同一个栈内存的指针仍然不安全.

---
内存分区模型:
全局区:全局变量,静态变量,常量:程序结束后由操作系统释放

---
初始化列表给属性赋初值
Person(): m_a(10),m_b(20),m_c(30){}
下列形式也是一种初始化列表赋初值
Person(int a, int b, int c): m_a(a),m_b(b),m_c(c){
没什么原理,就是这么规定的一种初始化写法.

---
类对象作为类成员,构造的时候会先构造成员中的类,和赋不赋初值没有关系.
析构顺序和构造相反.先析构大类在析构成员类. (类似于栈,后构造的先析构)

---
静态成员
静态成员变量:1.所有变量共享一份数据; 2.在编译阶段分配内存; 3.类内声明,类外初始化(不初始化无法访问,初始化语句只执行一次)
静态成员函数:1.所有对象共享同一个函数; 2.静态成员函数只能访问静态成员变量.

---
c++对象模型和对象指针:
1.成员变量和成员函数分开存储
  只有非静态成员变量才属于类的对象上.
空对象占用内存空间为1

---
**this指针**
用途:this指针指向被调用的成员函数所属的**对象**(指的是类对象),用于使成员函数区分当前调用是哪个对象来进行的.

---
空指针调用成员函数
空指针仍然可以访问不涉及(非静态)成员变量的成员函数

---
const 修饰成员函数
`void showPerson() const {`
常函数: 常函数内不能修改成员属性,使用mutable后则可以调用.
常对象: 只能调用常函数,常对象中加了mutable的成员变量也可以进行修改.

this指针本质是指针常量, 指针常量不可以修改. 也就是 Person * const this;
而成员函数加上const后,相当于this指针变成了: const Person * const this;

const修饰指针,对于一个指针eg int \* ptr; \*左边修饰指针指向的值(例如int \*说明指针指向的是一个int类型的地址), \*右边修饰指针本身. 因此 int \* const ptr意味这ptr的地址不能改,但是ptr指向的int值可以改.而 const int * ptr意味着ptr地址可以改,但ptr指向的是一个常量int地址. 所以可以出现**cost int \* const ptr**的情况,意思是指针和指针指向的值都不能更改.


##### 0314
晚上再看一下0222
整理一个笔试卷中的内容

滑动窗口:
1.对于发送方而言.三段. 2.意义发送窗口内数据不会超过接收方缓冲池. 3.由接收方告诉,保证可靠连接基础上充分利用网络资源.
MSS:TCP数据段最大长度(不算TCP报文头的长度); 放在选项部分; 建立连接时定义.
MTU:数据链路层的数据报大小.若MTU=1500,意思是IP头部+TCP头部+TCP数据一共最大1500.又由于IP-头部最小20,TCP头部最小20,则MSS最大1460.

----
IP地址和掩码问题:
对于ip地址255.255.255.255
A,B,C类地址:前1,2,3为网络地址,后3,2,1为子网地址.
子网地址:x.x.x.x的表示,二进制转换之后会变成1111111,0000这样的,'1'的部分就是网络地址,'0'的部分代表子网地址;子网表示192.168.0.0/24 意思是前24是网络地址,后8位是本主机.所以可用的子网ip应该从192.168.0.0到192.168.0.255. **24不需要再进行二进制转换.**

A,B,C类地址判断:
1开头到126开头是A类网络/128开头到191开头是B类网络/192开头是C类网络.

一个 C 类网络被划分子网，新的子网掩码是 255.255.255.224，下列哪个地址将会是其中某个子网的广播地址.
这道题考察就是,首先子网划分.计算224=128+64+32,则后五位是本地主机.广播则后五位要全是1,查看选项中符合后五位全1的即可.

(有效子网):要首先判断网络地址类型,再和子网掩码比较.例如B类网络,后16位可以分割本地ip,子网掩码有13位,则16-13可以有8个子网地址.但要-2因为全0是内环全1是广播.(要不要-2这个目前有争议)

**模拟笔试**
*动态链接库*的知识:
libxxx.so; 静态库,链接阶段静态库代码会被打包到可执行程序中; 动态库,连接阶段代码不会被打包到可执行程序中.
-L 库路径 -l 库名称
  **要背**静态库:优点:1.静态库被打包到应用程序中,*加载速度快*; 2.发布程序无需提供静态库,*移植方便*;
                缺点:1.消耗系统资源,浪费内存(多个程序用了同一个库)  ; 2.更新部署发布麻烦.(库更新之后程序要重新编译)
          动态库:优点:1.可以实现**进程间资源共享**(共享库),只要动态库被加载到内存中了,其他进程调用时就不会i再重复加载,这也是动态库**减少页面交换**的原理.; 
          2.更新部署发布简单(对应用程序而言) 3.可以控制何时加载
                缺点:1.加载速度比静态库慢. 2.发布程序需要提供动态库文件.

n个数值选出最大m个数（3\<m\<n\）的最小算法复杂度是
我选的是nlogm我仍然认识我是对的.问题有争议.nlogm是小根堆做法(也是高赞回答的做法).至于计数排序,要看n个数之间差值有多达,如果是稀疏的,复杂不可能是n.

以下哪种方式，在读取磁盘上多个顺序数据块时的效率最高？

中断控制方式; DMA方式; 通道方式; 程序直接访问方式; 循环检查I/O方式

I/O中断方式是以字节为单位，DMA控制方式是以一个连续的数据块为单位，I/O通道控制方式是DMA控制方式的发展，是以一组数据块为单位的，即可以连续读取多个数据块。
-  DMA控制器受到cpu命令,自动的完成数据从磁盘到内存的搬运,传送过程中不需要cpu参与.比起传统(直接访问和循环IO)要快(一个数据块一个数据块.). 通道方式比DMA更高级,有程序参与,完成一组数据传输(多个块).
-  先进程度依次为:循环IO->中断->DMA->通道
[链接](https://wenku.baidu.com/view/566b9b5702f69e3143323968011ca300a6c3f6c2.html?_wkts_=1678803107794&bdQuery=%E9%80%9A%E9%81%93%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%9D%97)


只要记住:**大端字节序就是字节储存和人类阅读顺序一致的存储方式.** 也就是低地址存高位.

第一次听到'半连接'这个词汇.不过通过半关闭这种词,也就好理解了.

**内存对齐应用题**
*指定对齐:* #pragma pack(2) 以2字节内存对齐
*自然对齐:* 按照参数本身的大小进行对齐(例如,int按照4对齐这样.)
特殊规则: 结构体大小要为最大对齐数的整数倍,union,enum也有这种要求
函数:如果除了函数没别的东西,则其有1个空间,否则不占空间.
typedef声明也不算内存
enum按一个4;
实在不会就碰运气吧.不要选奇数就对了.

对于int*p=0; 这句话应该理解为指针p指向了地址0,而不是指针p指向了0所在的地址(指针对向存整形指针.). **0在此时被理解为了地址0,属于二义性**
p+=6,p依照自己的地址增加了6.(但是6个字节寻址,最后地址就是24); *很奇怪的一点是,任何类型指针都可以指向地址0*

HTTP FTP在应用层
TCP UDP在传输层
ICMP,IGMP(目的是让网络系统知道当前主机所在的多播组),IP,ARP(ip地址反求物理地址)在网络层
VPN协议在很多层都有，虚拟专用网VPN， 数据链路层VPN， 网络层VPN，  SSL‐VPN 

##### 0313

Cpp视频90
**八股:**
1.复习:
(来源:复习守护进程时)umask掩码:每个进程通过umask确定自己创建/修改文件的权限.清空则拥有最大权限. 这个和sigaction中的sa_mask是两回事.
守护进程创建步骤:父进程创建子进程,子进程创建自己会话,关掉父进程,子进程清空umask,修改文件描述符的123位dev/none

2.学习:CPP类
成员函数,成员变量;CPP是编译型语言,所以变量定义先后顺序不影响引用.
**引用**:给变量取别名;两个名字;**必须初始化**;**一旦初始化后不可以更改**(赋值不是更改);

```cpp

int & b =a;
//本质上是const int * 类型指针,但是经过封装了.相当于b和a代表的同一块地址
//返回值是引用的函数可以做左值.记住本质是代表同一块地址的名称.就好理解为什么传进函数里面去修改,函数外面的也会修改了.记住本质上是个const指针,就好理解为什么不能指向别的函数了.(const指针直接报错,引用解释为把该地址的值改为右值的值)

int main()
{
    int a = 10;
    int &b = a;
    b=5;
    cout<<a<<endl;
}
```
修改原变量的值会在其原内存中修改数,而不会新创建内存.

```cpp
int a = 10;
int &b = a;
cout<<&a<<endl<<&b<<endl;
b=5;
cout<<&a<<endl<<&b<<endl;

0x7ffe94fde02c
0x7ffe94fde02c
0x7ffe94fde02c
0x7ffe94fde02c
```
cpp中的值实际上就可以理解为内存的名称.
**引用也可以在函数中修改函数外值的解释:**引用就是别名,说白了就是符号所代表的地址相同.正常函数传参,函数内外参数(形参/实参)地址不一样,所以改变函数内部参数地址不会影响函数外部.但引用相当于通知了函数,形参实参地址是一样的,那函数内部修改当然会影响函数外部.

**static** 关键字修饰局部变量的本质:不管是类中,还是函数中.局部变量加上static都会存放在全局区,在进程结束后由系统释放.
static修饰局部变量(成员变量),为让**变量生命周期直到进程终止**.同时存放在data段. 记住了这一点,其只能被声明一次的特性也好理解了.对于**成员变量**而言,其独立于类实例,可以被类直接访问也好理解了.
static修饰成员函数:静态成员函数,不含this指针.其可以通过类访问的特性在单例模式中会被使用.
----下面两个用的见的都不多
static修饰全局变量,让全局变量的可见范围局限在当前文件. 
static修饰函数,限制作用方法.

引用本质是int \* const指针; 引用前加const变成常量;
*但引用被封封装的并不支持查看指针地址等一系列指针相关操作,而是可以 当成 是变量的有一个名字.*

一个额外的任务,每天看一点C++知识视频,补充一些自己没了解过的CPP知识,磨刀不误砍柴工.314个视频,但不是每个都看,有很多基础知识不用看(P80之前的),有很多项目视频也不用看.最后可能需要看的也就100多个.每天多哪个知识点感兴趣就看一看.也不需要特别认真的梳理.了解有这么回事即可.后面有需要再回来看.因为不用到,或者感到困惑的话,是很难让我记得清晰.看过能复习一遍就行

c++三大特性:封装,继承,多态
**封装:**属性和行为作为一个整体;整体.类就是一种封装思想的体现.属性主要代表变量/常量. 行为就是函数. 就是python中的class
访问权限: **public**成员:类内可以访问,类外可以访问, protected类内可以访问,类外不可以访问 , **private** 类内可以访问,类外不可以访问. 子类可以访问父类中protected内容.而private类中的内容任何继承都访问不了.
**struct 和 class区别:**唯一的区别就是默认访问权限不同.struct默认位public,class默认为private
设置属性设置为私有的好处,通过函数修改属性:1.可以自己控制读写权限 2.对于写权限,可以检测数据有效性.

**对象初始化和清理:**-> 构造函数(初始化)和析构函数(清理). 构造函数类似于python中class中的__init__. 如果不提供构造和析构,默认为空实现.构造/析构函数都没有返回值.不用写void.构造函数可以传参,可以重载.析构不能.销毁前会调用析构函数.

**内存对齐的内容和意义:**意义:CPU寻址不是按字节访问,而是按word size访问.如果数据结构在自然边界对齐则可以一次去除.**对齐系数**(大概就是word size大小了),32位是4,64位是8. **结构体成员变量的顺序会影响结构体的内存布局.**

**C++对象模型和this指针** 
C++会给空对象分配1字节内存空间,为了区分空对象占内存的位置.
成员变量和成员函数分开存储;静态成员变量,不属于<类对象>(实例化的)上.非静态成员函数,不属于实例化的类对象上.静态成员函数也不属于类对象上.

##### 0312

**哪些场景下select比epoll更合适?**
(来源:0声教育视频课)IO数量不多(内核事件表中连接数不多)并且多线程(多线程访问内核事件表). 因为红黑树要加锁 

###### 项目
C++中的时间类 time_t [网址](https://www.runoob.com/w3cnote/cpp-time_t.html)
世界协调时:UTC 格林威治时间(可以认为UTC=GMT),格式为**年月日时分秒**.
计算机中的UTC: 从1970/01/01开始的**秒数**.
LT:当地时间,例如北京就是UTC +8.

**time_t**:储存从1970到现在经过了多少秒
**timeval**:一个结构体,里面储存两个变量(long tv_sec; long tv_usec),一个是经过了多少秒,一个是经过了多少微秒.
**tm**:一个结构体,里面出存了9个变量,可读性较强.其中比较容易理解的七个为年,月,日,时,分,秒,兴起.
**localtime(time_t)**:(最常用)将UTC秒数转换成本地时间,储存在一个tm结构体中.

**gmtime(time_t)**:(不常用)将UTC秒数转换成GMT时间,储存在一个tm结构体中(除了生活在GMT时去的人以外谁又有这个需求呢?)

fopen,fclose,fputs,fflush:


##### 0310

###### 八股(复习)
**五种IO模型:**
阻塞,非阻塞,IO复用,信号驱动,异步
EAGAIN:就绪取没有数据,返回改错误号给read函数提示其下次再尝试

**IO模型中的同步和异步与进程通讯间的同步和异步有何区别和异同**
IO模型中同步:数据由就绪态到读写态是进程处理的
IO模型中异步:数据由就绪态到读写态是内核处理的,处理好了发个信号
进程通讯间同步:阻塞执行
进程通讯间异步:非阻塞执行(交给工作线程处理)

**什么是虚拟内存?作用是什么**
内存控制单元(MMU)所建立,的不连续的物理内存,和部分磁盘空间映射到了一拼连续到虚拟内存中.让每个进程看起来拥有一片连续的内存单元.作用:定义了一块连续的地址空间.把内存扩展到了磁盘.

**虚拟内存是如何利用外存空间的:**
局部性原理.(时间/空间)局部性.可以将程序的一部分装入内存.

**用户态到内核态转化的原理:**
其实就是中断产生的哪几个方式.(软中断:)系统调用,异常.(硬中断:)硬件故障.

**038中断是什么?有哪几类中断?中断是如何实现的**
进程在执行过程中,cpu发生了紧急需要处理的事件.需要保存进程的执行线程来执行中断程序.中断可以分成外中断和内中断.内中断又被称为异常.
内中断:当前进程产生的中断(系统调用),缺页/端点/溢出等等. 外中断:**硬件(鼠标键盘网卡等)产生的中断**. 具体情形有:硬件故障,时钟,IO
实现:大体可以分成三个步骤.保存当前进程执行的现场.执行中断程序.恢复现场.

**043LT模式和ET模式分别是什么,有何优缺点**
以读事件为例.LT模式下如果文件描述符的读缓冲区有内容,epoll_wait每次都会返回它的事件.ET模式下只会返回一次.(除非有新内容到缓冲区了.).减少epoll触发次数,效率更高.
**[验证:]**ET模式下如果前一个数据没读完,然后又来了新的数据,会不会通知.

##### 0309

#define:
'#'预处理执行,从#后开始运行,到第一个换行符为止,也就是说只有一行
#define 宏 替换体

**在#define中使用参数**
在#define中使用参数可以创建外形和作用与函数类似的类函数宏.
#define MEAN(X,Y) (((X)+(Y))/2)
宏定义不做计算,不求值,只替换
LOG_INFO(format, ...)可变参数宏,传入不定长参数

**项目:**
日志系统:初始化,通过懒汉模式,静态函数+静态局部变量初始化
get_intance->init init日志中同步和异步的逻辑分别是什么?
同步和异步的设计:说白了,同步就是主线程来记录日志(可能会阻塞),异步就是额外创建一个线程处理日志的写录工作.

<string.h>中的四个函数(集中出现在log.cpp line62-line68之间)
**strcpy:**
char\* strcpy(char \* dest, const char \*src):
功能:从src地址开始且含有\0结束符号的字符数组拷贝到dest开头的地址中,返回指向dest的指针,当然也可以通过传入参数dest进行访问.

**strncpy:**
char \* strncpy(char \* dest, const char \* src, int n)
功能:把src所指向的字符串中的地址开始的前n个字节复制到所指的数组中,并返回被复制后的dest.


**[优化:]**压力测试的时候选择异步日志IO应该处理速度会更快吧?

**原码反码补码:**
补码=原码取反+1, 负数存储是补码,求得方式是对应正数连同符号取反+1.
原因:可以将**符号为也纳入计算**,即正数-正数=正数+(-正数)=正数原码+负数补码,得出来是啥就是啥 ,并且0只有唯一表达.

**大文件:**[参考网站](https://github.com/doocs/advanced-java/blob/main/docs/big-data/find-top-100-words.md)
总结一下,这类问题用hashmap+堆一定可以解.还有有一些比较巧妙的方法比如**位图**或者**前缀树**可以因地制宜的应用.

2^32b是512MB,说32位cpu寻值4G是因为cpu寻值按字节算
**如何在大量的数据中找出不重复的整数？**
在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。

**解析:**居然可以存位图也是没想到.这样一个数用2bit储存,最多有2^32个数,可以用1G内存判断.挺牛逼.

**如何从大量数据中找出高频词？**
有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。
**解析:**在hash后用小文件纪录之后,用一个小根堆动态维护.这样比每个小文件建一个小根堆要节省空间(也不用多级处理了.)

**如何从大量的 URL 中找出相同的 URL？**
题目描述 给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。
**MA:** 1.先把a用哈希函数分到M个小文件中,每个文件可以单独放进内存.2.再把b用哈希函数同理(键位url,值为ct次数). 遇到重复的直接保存在一个单独的文件中.
**A:** 首先计算空间啊:url共250GB+,内存4GB,因此放进70个小文件中即可. 具体把一个url放进一个小文件并哈希的方法,首先得到哈希值hash(url),这个哈希值用来唯一寻值一个url.然后比如对hash%70,余数代表与值对应的小文件. 对于挑文件的过程,遇到重复的直接


##### 0308
**[优化]:**线程池也可以是单例模式.

##### 0307

##### 进程间通信:

进程间通信(IPC): 通信:发消息.
目的:数据传输, 通知事件, 资源共享, 进程控制
管道(匿名,有名), 信号, 信号量, 内存共享,内存映射, UNIX套接字, 消息队列

**信号**:内核通知程序,往往伴随中断.值传递一个信号信息.用于**通知事件,和进程控制**
**信号量**:在进程间维护共享资源,用于**资源共享**

剩下,管道,内存共享,套接字,消息队列才是用来通信的:
管道:内核内存中维护的缓冲器,字节流.数据流动: 进程A缓冲区(用户)->管道缓冲区(内核)->进程B缓冲区(用户).
这说明 不同进程可以共享相同的内核区或用户区的物理内存空间,只是进程自己看起来在虚拟内存空间中是独立的而独占的 这个我之前是没有意识的. 使用场景:短通信,信息交互.但不适用于数据传输.写入大小受管道缓冲区限制.

**匿名管道(pipe):** 单向.半双工.有文件描述符但没有文件实体. eg `ls | wc -l` `|`就是管道符. 管道将ls的标准输出改为管道的写入端, 将wc的标准输入改为管道的读取端.达到了将ls的输出作为wc -l输入的效果. **使用场景:** 父子进程通信.

**有名管道(FIFO):** 单向.半双工.有文件实体但不存储数据,内容还是存放在内核缓冲区. **使用场景:** 非亲缘关系的进程进行通信

**消息队列** 消息的链表,在内核中,随机查询. (用的比较少.)

**内存映射(共享文件):** *mmap*效率高.将磁盘文件的数据映射到内存当中.通信原理:两个进程映射同一块文件的同一部分.修改内存后内核会自动修改映射的磁盘地址.可以通信大文件,但读取每次都要从磁盘读.读数据流:写:用户内存->磁盘;读:磁盘->内存. 如果是单纯的read,write磁盘文件写:用户内存->内核内存->磁盘,读反之. **使用场景:** 单机进程间大文件通信. {言外之意,虚拟地址空间可以扩充到磁盘空间,也就是内存虚拟地址空间只受cpu寻址限制,具体怎么分配和管理应该由mmu控制. }

**共享内存:** 和内存映射类似,但是文件存放地址从磁盘变成了内存.这样文件传输量受物理内存大小限制了,但是读写速度极快. **使用场景:** 单机进程中等文件快速通信.

**UNIX套接字:** 双工.省去了部分协议过程,相比于ip套接字效率更高,保证连接稳定.
无名套接字:socketpair创建,非亲缘关系进程不能使用
命名套接字:任何两个进程都能用.

##### 0305

> [八股],[操作系统], **虚拟内存** **虚拟地址空间** **虚拟地址空间到物理地址的映射**:通过CPU中的内存管理单元(MMU)

select/poll

> [八股],[操作系统],  **系统调用:**为了管理硬件/系统资源的请求,采用了权限管理,把软件状态分成了**内核态和用户态**.用内核态权限更高,有权访问硬件/磁盘.linux通过**软中断**的方式实现系统调用.进程的用户态和内核态都是同一个进程在执行(对应相同的虚拟地址空间.)只是进程可以在内核区(通过内核态)访问系统硬件api.

---

##### **信号:**
软件中断,异步通信.的信号**用户,系统,进程** -> **发往目标进程**. Ctrl+C:中断信号.系统状态变化,SIGALARM. 可以理解为一种linux默认设置好的内核和进程交流的窗口.进程中没有显式代码接收.项目中所调用的sigaction是更改信号默认处理方式的一个函数. 信号的状态:1.产生(事件被触发,由内核产生信号) 2.内核向进程发送过程,未决状态 3.进程收到信号,递达状态.

**目的:**1.**通知**进程发生了特定事件.2.强迫进程执行它自己代码中的信号**处理程序**.

项目中所处理的信号SIGPIPE, SIGALRM, SIGTERM;
其他一些**常见的信号**:(2)SIGINT:程序终止信号,Ctrl-C输入,通知前前台程序结束运行,可以被阻塞;  (3)SIGQUIT:终止程序运行,Ctrl-\输入,也可以被阻塞. (15)SIGTERM:程序结束信号,也可以被阻塞.(9)SIGKILL:强制结束程序,不能被阻塞. (19)SIGSTOP:停止程序执行.暂时停止.不能被阻塞.

**信号相关函数:** kill(pid,sig), raise(sig), abort(void);
系统状态变化,定时器,int alarm(int seconds) --时间到发送SIGALARM,默认终止进程,每个进程定时器唯一,后alarm会刷新原alarm.时间是真实时间;
周期性调用:setitimer

**信号捕捉函数:** signal: signal中的回调函数是内核调用(系统调用),也就是在内核区去执行如何处理. 调用signal向内核区注册回调函数. sigaction,增加了信号集概念,功能比signal更完善.
signal和sigaction异同:1.sigaction 具有临时阻塞信号集的功能. 2.singal是美国ansi c标准,在不同版本linux行为可能有不同.sigaction执行posix标准,表现稳定.(这也是八股中所提到的singal版本不稳定问题.)

**信号集:**(信号的集合).进程控制块PCB中有两个信号集,位图实现:
1.**未决信号集**(标志位为0-非未决, 标志位为1-未决待处理) 未决信号集不能修改只能获取. sigpending:获取内核中的未决信号集.
2.**阻塞信号集** (阻塞信号递达.0非阻塞, 为1阻塞) 操作函数:sigemptyset, sigfillset, sigaddset, sigdelset, sigismember; 阻塞信号集通过*sigprocmask修改(将自定义信号集中的数据设置到内核中*,设置阻塞,接触阻塞,替换);

**sigaction:**信号捕捉哈函数. sigaction(...,const struct \* sigaction,...)
sigaction里面就sa_mask,sa_handler有用,剩下的都没用.

```cpp
struct sigaction{
void (\*sa_handler)(int); //信号处理函数
void (\*sa_sigaction)(int, siginfo_t \*, void \*);
sigset_t sa_mask; //临时阻塞信号集,信号捕捉函数执行过程中,临时阻塞
int sa_flages; //指定是用sa_handler处理还是sa_sigaction处理 (默认sa_handler)
void (\*sa_restorer)(void); //废弃
}
```

**通过匿名套接字进行信号处理的过程:**
**信号处理函数在哪里被执行的:用户区**具体流程如下
1.在执行主控制流程的某条指令因为中断,异常或系统调用进入内核
2.内核处理完异常准备返回用户模式之前先处理的那个前进程中可以递送的信号(信号处理)
3.如果信号的处理动作为自定义信号处理函数,回到用户模式处理(**但不是回到主控制流程(即不是回到int main()中)**)
4.信号处理函数返回时执行特殊的系统调用,sigreturn再次进入内核
5.sys_sigreturn()返回用户模式从主控制流程中上次被中断的地方继续向下执行.

**函数指针和回调函数:**

> * cb_func是一个函数指针,这里是定义了一个cb_func的函数指针,指针的地址是函数
> 为的是后面定义某些回调函数的时候,把cb_func作为参数传进去
> 函数回调:在函数中调用函数的做法
> 回调函数:在函数中被调用的函数.在这个定义下,\*cb_func确实是一个回调函数
> 回调函数的实参可以在调用函数外部作为参数传递进去也可以在调用函数内部定义

**TIMESLOT**:最大超时时间,默认为5秒

> **C语言单例模式构造:**
> 首先将类构造函数声明为private; 其次声明一个静态的函数指针 `static connection_pool *GetInstance();` ,返回值是一个类实例;在指针函数中定义一个静态类 `static connection_pool connPool;`并返回该类的地址.

> 这三步的功能:1.构造函数设为私有,则不能在类外部使用connection_pool connPool进行实例化(因为实例化需要调用构造函数). 2.静态的函数指针,类中的静态方法/静态变量可以通过类名的方式进行非实例化调用. 3.静态局部变量(静态类),**声明**语句只会执行一次(注意不是赋值语句).所以每次调用类中的 `get connection_pool`都会跳过初始化过程.返回为一初始化的类地址.

> 静态变量的特质是因为存放在data段(全局变量存放段).作用域结束不能访问但不释放内存.因此下次访问还保有上次的值并且不能反复初始化.同样,因为静态变量一致存在的特点.类中的函数和方法可以不实例化类型就能调用.这个特点就可以解释单例模式下对static关键字的使用.

**[验证:]**类中的静态方法,变量都可以通过类名的方式进行调用和初始化.

C语言中的Static

- static对于变量

  - 局部变量(静态局部变量)

    在局部变量之前加上static,局部变量就被定义成静态局部变量(在函数/if,while,for循环中定义的变量都是局部变量)
    内存位置:data段
    初始化:只能被初始化一次
    作用域:局部作用域,函数或语句执行完毕就会随之结束
  - 全局变量(静态全局变量)

    在全局变量之前加上关键字static,全局变量就被定义成一个静态全局变量
    内存中的位置:data段,静态存储区(静态存储区在整个程序运行期间都存在)
    初始化:未经初始化的静态全局变量会被程序自动初始化为0
    作用域:静态全局变量在声明它的文件之外是不可见的.准确的讲,是从定义开始之处到文件结尾.(与之对应的全局变量在所有文件中都是可见的)
    补充:全局变量本身的就是静态存储方式,静态全局变量当然也是静态存储方式.区别再于非静态全局变量的作用域是整个源程序,当一个源程序由多个源文件组成时,非静态全局变量在各个源文件中都是有效的(在其他源文件使用时要加上extern关键字重新声明).而静态全局变量则限制了其作用域,即只在定义该变量的源文件内有效,在同一源程序的其他源文件中不能使用它.
- static对于函数
  修饰普通函数,表明函数的作用范围,仅在定义该函数的文件内才能使用.防止重名.
- static对于类

  - 成员变量(静态类变量)
    用static修饰类的成员变量时,其成为类的全局变量,会被类的所有对象共享.因此,一般在类外面初始化.
  - 成员函数(静态类函数)
    static修饰成员函数,变成可以独立访问的函数.

总结:static目前主要作用有两个,一个是改变变量/函数的声明周期;另一个控制函数只能执行一次赋值操作

##### 0304

时钟系统:储存文件夹: lst_timer.h; lst_timer.cpp
初始化函数:在webserver中

**[优化3:]**处理不活跃连接,如果连接断开,应该重新登陆用户名和密码才能访问具体数据.但当前服务器并没有实现这个业务逻辑.

##### 0303

数据库部分:首先,主函数line32 sql_pool()包括实例化数据库连接池,初始化数据库连接池,
以及users->initmysql_result(m_connPool)

数据库连接池工作逻辑:
在最开始调用sql_pool生成连接池.每当线程池执行http请求的时候,调用connectionRAII取链接,存在http请求中的mysql中.然后执行具体的业务逻辑.connectionRAII在析构的时候自动释放链接.

**[优化1:]**连接池在每次线程process之前读取,但实际上不是每次都需要访问数据库链接,应该放在process中需要访问连接的时候再取,减少访问次数.

**[验证]:**http_conn.cpp line23的猜想

**优化2:**我可以讲这个故事:一开始每次查询我都是设置向mysql中查询.后来我定义了一个缓存http_conn line25 users,先取出mysql中的数据,存在一个共享的字典中.每次查询都向该字典查询. 是否存在线程同步的问题?

##### 0302

**[bug:]**关于数据库连接池中的数据库连接池表只在第一个http请求队列中被定义但在多个连接过程中都可以被访问到的bug.
**[解释:]**起始没有bug,取连接的所不是initmysql_result函数而是connectionRAII函数,而该函数会在工作线程执行process的时候被调用

**[bug:]**即是在客户端同时创建多个窗口,窗口所建立连接的文件描述符仍然是同一个文件描述符

先带着bug继续往下看代码.

验证,结构体数组构造,首指针调用函数是不是只有第一个元素执行了该函数:

##### 编译服务器项目

`sh build.sh`

##### 0301

[数据库]RAII: Resouce Acquisition Is Initialization
函数析构的时候自动回收内存;原理:构造及申请,析构即释放

重新生成server可执行文件语句:

##### 0228

我在哪里用到了信号量呢:

1.线程池中的线程执行http请求队列中的请求的时候
2.数据库连接池中的连接被请求的时候.

actormode:
-a actor_model
文档里的解释:
0:proactor 1:reactor
定义:reactor:工作线程处理读写请求 proactor:主线程或者内核处理读写请求
主从reactor:

- 之所以记忆出现了混乱是因为后面看Netty里面讲主从reactor,对于多线程reactor定义和游双书中不一样.还是按照游双书来记忆.reactor是工作线程中处理读写,模拟proactor是主线程处理读写.但这里由于主从reactor游双书中没有定义,因此选择netty中的解释:主reactor只负责建立连接,从reactor负责读写并把任务分配给子线程.

```cpp
//线程池相关
//互斥锁+信号量从请求队列里面取请求
//互斥锁:m_queuelocker 信号量:m_queuestat
m_queuestat.wait()
m_squeue.locker()
if ()

```

##### 0220

- **casual note**

[**简历里面**]可以增加关于信号量的相关知识内容

后面还要继续补充的技术栈: \[html\](应该很好学),\[redis\](学个大概),\[nginx\]()

nginx 高性能的HTTP和反向代理web服务器. 正向代理,代理客户端. 反向代理:代理服务器端. 对客户端请求,自动转发给不同的服务器.保证连接稳定以及负载均衡.
负载均衡策略:轮询,加权轮询,
还有还有动静分离功能.

##### 0216

- **casual note**

先看http解析请求部分,看完http再把eventloop中涉及的其余函数(比如read,write等等)看了, 最后是定时器/日志系统的部分

后面有两个**继续深入学习该项目**的情景: 1. 自己在原来系统的基础之上,重新实现诸如LT模式, 定时器等模块,加深对于内核交互部分的理解. 2. 扩展上传文件的功能,扩展和python搭建的人工智能交互的功能.

**HTTP协议**:
无状态的,以请求/应答方式运行的协议

请求方法:GET POST HEAD PUT (前面则几个比较常用)  TRACE DELETE OPTIONS

HEAD: 和GET基本一致,只是不返回内容

##### 0215

**半同步/半反应堆线程池**的理解:
工作线程按顺序逻辑执行抢到的客户端请求,属于同步模式.主线程平时维持自己的事件循环,当有请求接入时,处理相应的请求(建立连接/IO/信号量等等),属于异步模式中的反应堆.所以模拟proactor和reactor模式都属于半同步/半反应堆线程池.

为什么只是计数的信号量很重要:因为信号量是**原语**
`使用一个普通变量来模拟二进制信号量是行不通的,因为所有高级语言都没有一个原子操作可以同时完成如下两步操作:检测变量是否为true/false,如果是再将它设置为false/true`

对于*'LT模式文件描述符既可以阻塞也可以非阻塞'*但*'ET模式下文件描述符必须非阻塞'*的理解:
为了方便理解,我们对阻塞的文件描述符进行具体的定义.阻塞:在读缓冲没有数据的时候,调用write函数不会返回值,而会阻塞在那里.非阻塞:在读缓冲没有数据的时候,调用write函数会返回-1以及错误号EAGAIN.

**LT模式下文件描述符阻塞**: 不使用while循环读取文件,一次只读取一个readbuf大小的文件,如果读缓冲区还有剩余也结束分支等待epoll下一检测的激活唤醒.效果:每次都会在缓冲区有数据的时候被提醒,不会卡死.

**LT模式下文件描述符非阻塞**: 可以使用while或不使用while均可.不使用while的话就和LT+阻塞等效了.使用while的话和ET+非阻塞等效.

**ET模式下文件描述符非阻塞**: 使用while循环读取文件,每次将读缓冲读空之后返回一个EAGAIN,标志着本次读取完成.ET模式下,只有新数据到来才会进行一次提示.

**ET模式下文件描述符阻塞**: 不使用while会面临一次读不完数据,不会再读下一次的问题.使用while会面临当缓冲池为空时阻塞不返回的问题.因此该组合不可行.

总结:*说LT模式下文件描述符既可以阻塞也可以非阻塞*,指的是不同的代码(具体指的是是否+while进行读取),而不是说简单设置以下nonblock就可以实现了的.

- casual note

验证一下ONESHOT,ONESHOT意思是就算有新数据来也不通知(直接把事件从内核事件表中删除了)

非阻塞I/O+ET模式读取完文件如何返回的问题: 判断返回值是0且错误号是EAGAIN/EWOULDBLOCK. 另外while和非阻塞是绑定的.如果while还阻塞的话,就会一直等待.

##### 0214

```c
struct linger{
  int l_onoff;netstat -anp | grep 9999 
  int l_linger;
}
```

case1 l_onoff=0: (**默认选项**)在closesocket的时候立刻返回,底层会将未发送完的数据发送完成后再释放资源,也就是优雅的退出.
case2 l_onoff!=0, l_linger=0: closesocket的时候立刻返回,但不会发送未发送完成的数据,而是通过一个RST包强制的关闭socket.(这样可以避免time_wait状态的出现?)
case3 l_onoff!=0, l_linger>0: closesocket的时候不会立刻返回,内核会延迟一个由linger值指定的值.

```cpp
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen)
```

下文来自UNIX网络编程
`sockfd`必须指向一个打开的套接字描述符,level(级别)指定系统中解释选项的代码或为通用套接字代码,或为某一个特定协议的代码
`SO_LINGER` 套接字选项:本选项指定close函数对面向连接的协议(例如TCP,不是UDP)如何操作.默认操作是close立即返回i,但如果有残留数据在套接发送缓冲区,系统将是这把这些数据发送给对端.(也就是优雅关闭连接)

`SO_REUSEADDR`允许启动一个监听服务器并捆绑其众所周知端口,即使以前建立的将改端口用作他们的本地端口的连接仍然存在.
`SO_REUSEPORT`一般不用这个

对**优雅关闭连接**效果的实验:

```bash
cd /home/qxy/Desktop/Job/Cpp_project/lession34-端口复用
#1.直接运行服务器和客户端,关闭服务器在立刻启动,会报错 无法绑定端口
bind: Address already in use
watch -n 0.5 'netstat -anp | grep 9999' 
#可以看到,前一个端口处于time_wait状态并没有关闭,这时把第server 26-27行注释取消,取消优雅关闭连接,立即返回
#再重复上述步骤,发现关闭服务器立即启动也不会报错,再查看netstat
watch -n 0.5 'netstat -anp | grep 9999'
#看不到上一个端口.这说明closesocket之后程序立即返回,并没有再发送数据或接收数据.
```

**水平触发/边沿触发**
这个概念隶属于epoll的工作模式,也就是说只有谈epoll的时候才有水平触发,边沿触发的概念.

listenfd和connfd分别可以选择水平/垂直触发模式,并且互相之间没有关联

触发模式是对于文件描述符(epoll事件)而言的,也就是说理论上每个epoll事件都可以单独确定不同的触发模式.在牛课Web项目的时候,把listen和con的触发模式统一处理了.Tiny项目中更加细化了,区分listenn和con可以有不同的触发模式.

水平触发,level trigger,LT  边沿触发,edge trigger,ET
水平触发:也是默认触发模式,epoll检测到了文件描述符已经就绪,如果不对其进行操作,下次检测还会提醒.
边沿触发:高速触发模式,epoll检测到了文件描述符已经就绪,只提醒一次.如果不对其进行操作,下次检测还不会提醒.
所谓**文件描述符就绪**,表述的是读缓冲区有数据可读(读事件),以及写缓冲区可写(写事件):如下表

|                      | 读事件               | 写事件       |
| -------------------- | -------------------- | ------------ |
| **就绪状态**   | 读缓冲区中有数据可读 | 写缓冲区未满 |
| **未就绪状态** | 读缓冲区为空         | 写缓冲区已满 |

水平触发在代码层面会轻松一些,因为如果一次没读完数据,epoll还会提醒,这样一次工作线程只要把读一点数据即可.如果还有剩余内容,再下一次提醒的时候继续读即可.
边沿触发,工作线程要一次性把所有发送的内容全读进来,并且还要重置事件使其可以在此被触发.
边沿模式下读写事件的触发情况:*读*:有一条新的数据进入到读缓冲区,会触发. *写*:缓冲区从满到不满,会触发.

##### 0213

先看线程池类,正确两个半小时把线程池类看完(今天)

- casual note:

是怎么组织文件的呢?主文件,通过config.h就把所有的文件都引入进来了?
`void parse_arg(int argc, char*argv[]);`

sh ./build.sh执行的是 `make server`语句,用 `make`进行文件的编译,得到 `server`可执行文件

```makefile
#make的一些基本语法
$@ 表示目标文件
$^ 表示所有的依赖文件
$< 表示第一个依赖文件
$? 表示比目标还要新的依赖文件列表
```

server:
  users: http_conn[MAX_FD],
  users_timer: client_data[MAX_FD],

问题:计时器作用是啥阿?啥时候会关闭连接呢?
那些参数设置不同值会产生什么影响?
最终实现上传文件并处理上传的文件的功能.估计还是改http那部分
梳理webserver中的所有参数最终都是负责哪个模块的?

##### 0212

- [X] 跑通webserver

属性:

* 1.使用**线程池**+非阻塞socket+**epoll**(ET/LT均实现)+事件处理(Reactor和**模拟proactor**均实现)的并发模型
* 2.使用状态机解析HTTP请求报文,支持**GET**和**POST**请求.
  * GET/POST都是请求网页的方式(向服务器传递数据).目前理解是GET一般是明码的,请求啥会出现在地址栏.POST是密码的,适用于提交用户名密码的这种情况.
  * httpbin.org
* 访问服务器数据库实现web端用户注册\登陆功能,可以请求服务器图片和视频文件
* 实现同步/异步日志系统,记录服务器运行状态
* webbench测试

比较了解的:
    [B/S模型], [线程同步机制包装类], [http连接请求处理类], 定时器处理非活动连接, 数据库连接池, 建议服务

##### 器压力测试

比较陌生的:
    半同步/半反应堆线程池, 同步/异步日志系统, 同步线程注册和登陆校验,
